<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>MARKETING DIGITAL / DIGITAL MARKETING</title>

<link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">

<style>
  body {
    font-family: 'Special Elite', monospace;
    background-color: black;
    color: white;
    max-width: 1000px;
    margin: 50px auto;
    padding: 20px;
    background-image: url('logo.png');
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
  }

  h1 {
    text-align: center;
    margin-bottom: 40px;
    color: #F8AC10;
    font-family: 'Special Elite', monospace;
  }

  /* NOWY STYL DLA PRZYCISKU "ODTWÓRZ WSZYSTKO" */
  #playAllBtn {
    font-family: 'Special Elite', monospace;
    background: #c63843; /* Użycie koloru highlight-z dla wyróżnienia */
    border: 1px solid white;
    color: white;
    cursor: pointer;
    padding: 10px 20px;
    font-size: 18px;
    border-radius: 5px;
    display: block;
    margin: 20px auto 40px auto; /* Centrowanie i odstęp */
  }
  /* --------------------------------------------- */

  .player {
    margin-bottom: 40px;
    display: flex;
    align-items: center;
    gap: 15px;
    font-family: 'Special Elite', monospace;
  }

  .karaoke-line {
    white-space: nowrap;
    font-size: 28px;
    display: flex;
    align-items: center;
    gap: 16px;
    font-family: 'Special Elite', monospace;
  }

  .word {
    transition: color 0.2s;
    font-family: 'Special Elite', monospace;
  }

  .highlight-es {
    color: #F8AC10;
  }

  .highlight-z {
    color: #c63843;
  }

  .completed {
    color: #9b835a;
  }

  .audio-container {
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  button {
    font-family: 'Special Elite', monospace;
    background: #F8AC10;
    border: 1px solid white;
    color: white;
    cursor: pointer;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    font-size: 22px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-right: 15px;
    flex-shrink: 0;
  }

  .time, .progress {
    display: none;
  }
</style>
</head>
<body>

<h1>MARKETING DIGITAL / DIGITAL MARKETING</h1>

<button id="playAllBtn">Odtwórz wszystko</button> <div id="players"></div>

<script>
// Tablica do przechowywania referencji do wszystkich playerów (audio i przycisków)
const allPlayers = [];

async function loadKaraoke(audioFile, jsonFile, container, type) {
  try {
    const res = await fetch(jsonFile);
    if (!res.ok) throw new Error(`No se encontró ${jsonFile}`);
    const data = await res.json();

    const playerDiv = document.createElement('div');
    playerDiv.className = 'player';

    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'audio-container';

    const playBtn = document.createElement('button');
    playBtn.textContent = '▶';
    controlsDiv.appendChild(playBtn);

    const karaokeDiv = document.createElement('div');
    karaokeDiv.className = 'karaoke-line';

    const wordsArray = [];

    data.forEach((item) => {
      const words = item.text.split(' ');
      const start = parseFloat(item.start.split(':').reduce((acc, time) => 60 * acc + +time));
      const end = parseFloat(item.end.split(':').reduce((acc, time) => 60 * acc + +time));
      const duration = end - start;
      const wordDuration = duration / words.length;

      words.forEach((word, j) => {
        const span = document.createElement('span');
        span.textContent = word;
        span.dataset.start = (start + j * wordDuration).toFixed(2);
        span.dataset.end = (start + (j + 1) * wordDuration).toFixed(2);
        span.dataset.type = type;
        span.className = 'word';
        karaokeDiv.appendChild(span);
        wordsArray.push(span);
      });
    });

    playerDiv.appendChild(controlsDiv);
    playerDiv.appendChild(karaokeDiv);
    container.appendChild(playerDiv);

    const audio = document.createElement('audio');
    audio.src = audioFile;

    let rafId = null;
    let completed = false;
    
    // Funkcja do usunięcia podświetleń i zaznaczenia jako ukończone
    const markAsCompleted = () => {
      completed = true;
      wordsArray.forEach(span => span.classList.remove('highlight-es', 'highlight-z'));
      wordsArray.forEach(span => span.classList.add('completed'));
      playBtn.textContent = '▶';
      if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
    }

    function highlightLoop() {
      const t = audio.currentTime;

      wordsArray.forEach(span => {
        const start = parseFloat(span.dataset.start);
        const end = parseFloat(span.dataset.end);
        span.classList.remove('highlight-es', 'highlight-z');

        if(t >= start && t <= end){
          span.classList.add(span.dataset.type === 'z' ? 'highlight-z' : 'highlight-es');
        }
      });

      if(t >= audio.duration - 0.1){ // Użycie małego marginesu dla pewności
        // MarkAsCompleted zostanie obsłużone przez event 'ended'
      } else if(!audio.paused) {
        rafId = requestAnimationFrame(highlightLoop);
      }
    }
    
    const togglePlay = () => {
      if(completed){
        wordsArray.forEach(span => {
          span.classList.remove('completed', 'highlight-es', 'highlight-z');
        });
        audio.currentTime = 0;
        completed = false;
      }

      if(audio.paused){
        audio.play();
        playBtn.textContent = '❚❚';
        if(!rafId) rafId = requestAnimationFrame(highlightLoop);
      } else {
        audio.pause();
        playBtn.textContent = '▶';
        if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
      }
    }

    playBtn.addEventListener('click', togglePlay);

    // Dodajemy callback, który można wywołać po zakończeniu odtwarzania
    let onAudioEndedCallback = null;
    
    audio.addEventListener('ended', () => {
      markAsCompleted();
      if (onAudioEndedCallback) {
        onAudioEndedCallback();
      }
    });

    // Zwracamy obiekt z kontrolkami do użycia w `playAllSequentially`
    return { audio, playBtn, togglePlay, markAsCompleted, setOnEnded: (cb) => { onAudioEndedCallback = cb; } };

  } catch (err) {
    console.error('Error al cargar karaoke:', err);
    return null;
  }
}

const playersContainer = document.getElementById('players');
const playAllButton = document.getElementById('playAllBtn'); // Pobieramy nowy przycisk

// Stabilna kolejność ES → EN → ES → EN dla 001...030
const order = [];
for (let i = 1; i <= 30; i++) {
  const num = i.toString().padStart(3,'0');

  order.push({
    audio: `https://raw.githubusercontent.com/xpanol/PLAYERS/main/${num}_es.mp3`,
    json:  `https://raw.githubusercontent.com/xpanol/PLAYERS/main/${num}_es.json`,
    type: 'es'
  });

  order.push({
    audio: `https://raw.githubusercontent.com/xpanol/PLAYERS/main/Z${num}_en.mp3`,
    json:  `https://raw.githubusercontent.com/xpanol/PLAYERS/main/Z${num}_en.json`,
    type: 'z'
  });
}

// Ładujemy w ścisłej kolejności, bez równoległości
async function loadAllSequentially() {
  for (const item of order) {
    const playerControls = await loadKaraoke(item.audio, item.json, playersContainer, item.type);
    if(playerControls) {
      allPlayers.push(playerControls); // Zapisujemy kontrolki
    }
  }
  
  // Po załadowaniu wszystkich elementów, aktywujemy przycisk "Odtwórz wszystko"
  playAllButton.disabled = false;
  playAllButton.textContent = 'Odtwórz wszystko';
}

// ----------------------------------------------------------------------
// NOWA FUNKCJA DO AUTOMATYCZNEGO ODTWARZANIA WSZYSTKIEJ TREŚCI
// ----------------------------------------------------------------------

let isPlayingAll = false; // Flaga zapobiegająca wielokrotnemu uruchomieniu

function playAllSequentially(index = 0) {
  if (index >= allPlayers.length) {
    // Zakończono odtwarzanie wszystkich
    isPlayingAll = false;
    playAllButton.textContent = 'Odtwórz wszystko';
    playAllButton.disabled = false;
    return;
  }

  const currentPlayer = allPlayers[index];
  
  // Zatrzymujemy inne aktywne playery
  allPlayers.forEach((p, i) => {
    if (i !== index && !p.audio.paused) {
      p.audio.pause();
      p.playBtn.textContent = '▶';
    }
  });

  // Ustawiamy callback, który przejdzie do następnego elementu po zakończeniu
  currentPlayer.setOnEnded(() => {
    // Czyścimy callback po wywołaniu
    currentPlayer.setOnEnded(null); 
    // Odtwarzamy następny
    playAllSequentially(index + 1);
  });
  
  // Odtwarzamy aktualny player
  // Jeśli już jest odtwarzany, to nic nie robimy (to jest zabezpieczenie)
  if(currentPlayer.audio.paused){
    // Upewniamy się, że player jest w stanie gotowym do odtwarzania
    if (currentPlayer.audio.currentTime > 0) {
      currentPlayer.markAsCompleted(); // Resetuje i ustawia completed na false
      currentPlayer.audio.currentTime = 0;
    }
    currentPlayer.audio.play();
    currentPlayer.playBtn.textContent = '❚❚';
    // Przewijamy stronę do aktualnie odtwarzanego elementu
    currentPlayer.playBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
}

playAllButton.addEventListener('click', () => {
  if (isPlayingAll) {
    // Jeśli odtwarzanie jest aktywne, zatrzymujemy je
    isPlayingAll = false;
    allPlayers.forEach(p => {
      if (!p.audio.paused) {
        p.audio.pause();
        p.playBtn.textContent = '▶';
      }
      p.setOnEnded(null); // Usuwamy callbacki
    });
    playAllButton.textContent = 'Odtwórz wszystko (Zatrzymano)';
    
  } else {
    // Rozpoczynamy odtwarzanie
    isPlayingAll = true;
    playAllButton.textContent = 'Zatrzymaj odtwarzanie (Auto)';
    playAllButton.disabled = true; // Tymczasowo blokujemy podczas odtwarzania, żeby nie zepsuć sekwencji
    
    // Włączamy z powrotem przycisk, aby można było zatrzymać
    setTimeout(() => {
      if(isPlayingAll){
        playAllButton.disabled = false;
      }
    }, 500);
    
    playAllSequentially(0);
  }
});

// Zaczynamy od wyłączenia przycisku, zanim załadują się wszystkie pliki
playAllButton.disabled = true;
playAllButton.textContent = 'Ładowanie playerów...';

// Właściwe ładowanie playerów
loadAllSequentially();
</script>

</body>
</html>